@page "/file-transfer/sender/{RoomId:int}"
@using Microsoft.Extensions.Configuration
@using Microsoft.AspNetCore.SignalR.Client
@using Toolbox.Pages.Enums
@using Toolbox.Pages.HashCheckService
@using Toolbox.Pages.Models
@using Toolbox.Pages.Shared.Dialogs

@inject IJSRuntime JSRuntime
@inject IConfiguration Configuration
@inject IHttpClientFactory HttpClientFactory
@inject NavigationManager NavigationManager
@inject IDialogService Dialog
@inject NavigationManager Navigation
@inject HashServiceFactory HashServiceFactory

<PageTitle>码术 - 文件传输</PageTitle>

<DialogLoading IsVisible="@_isLoading" ContentText="@_loadingMessage"></DialogLoading>

<MudPaper Width="100%" Elevation="0">
    <MudContainer MaxWidth="MaxWidth.Small">
        <MudPaper Width="100%"
                  Elevation="0"
                  Height="180px"
                  Square="true"
                  Class="pa-5 mt-10 d-flex flex-column align-center">

            @if (_connectionType == ConnectionTypeEnum.None)
            {

                if (!_isReceiverJoined)
                {
                    <MudText Typo="@Typo.caption" Class="mb-2">等待接收方进入....</MudText>
                    <MudProgressLinear Color="Color.Primary" Indeterminate="true" />
                }
                else
                {
                    <MudText Typo="@Typo.caption" Class="mb-2">正在连接....</MudText>
                    <MudProgressLinear Color="Color.Primary" Indeterminate="true" />
                    <div class="mt-2">
                        无法连接？使用
                        <MudElement HtmlTag="a"
                                    Class="ma-0 cursor-pointer"
                                    Style="color:var(--mud-palette-primary);font-weight:bold;"
                                    onclick="@EnableServiceRelay"
                                    rel="noopener noreferrer">
                            服务器中转
                        </MudElement>
                        发送
                    </div>
                }
            }
            else
            {
                if (_fileSentProgress == 0)
                {
                    <MudFileUpload T="IBrowserFile" OnFilesChanged="OnInputFileChanged" Hidden="false" Class="flex-1" InputClass="absolute mud-width-full mud-height-full overflow-hidden z-20" InputStyle="opacity:0"
                    @ondragenter="@SetDragClass" @ondragleave="@ClearDragClass" @ondragend="@ClearDragClass">
                        <ButtonTemplate>
                            @if (_fileSendName.IsEmpty())
                            {
                                <MudPaper Height="80px" Outlined="true" Class="@_dragClass">
                                    <MudText Typo="Typo.h6">
                                        点击这里选择文件 或 拖拽文件到该区域
                                    </MudText>
                                </MudPaper>
                            }
                            else
                            {
                                <MudPaper Height="80px" Outlined="true" Class="relative rounded-lg border-2 border-dashed pa-4 mud-width-full mud-height-full z-30">
                                    <MudChip Color="Color.Dark"
                                             Text="@_fileSendName" />
                                </MudPaper>
                            }
                        </ButtonTemplate>
                    </MudFileUpload>

                    <MudButton Class="mt-5"
                               Disabled="@(!_isAllowSend)"
                               Variant="Variant.Filled"
                               Color="Color.Info"
                               OnClick="@(async () => await SendFileAsync())">发送</MudButton>
                }
                else
                {
                    switch (_connectionType)
                    {
                        case ConnectionTypeEnum.WebRTC:
                            <MudText Typo="@Typo.caption">点对点发送</MudText>
                            break;
                        case ConnectionTypeEnum.ServiceRelay:
                            <MudText Typo="@Typo.caption">服务器中转发送</MudText>
                            break;
                    }
                    <MudText Typo="Typo.overline" Class="mt-1">@_fileSendName</MudText>

                    <MudProgressLinear Striped="true"
                                       Color="Color.Info"
                                       Size="Size.Large"
                                       Value="@_fileSentProgress"
                                       Class="mt-3">
                        <MudText Typo="Typo.subtitle1" Color="Color.Dark">
                            <b>@($"{Convert.ToInt32(_fileSentProgress)}%")</b>
                        </MudText>
                    </MudProgressLinear>
                }
            }

        </MudPaper>

        <MudPaper Width="100%"
                  Elevation="0"
                  Square="true"
                  Class="pa-5">

            <MudList Clickable="false" Dense="true" DisableGutters="false">
                @foreach (var message in _messages)
                {
                    <MudListItem Text="@(message)" />
                }
            </MudList>

        </MudPaper>
    </MudContainer>
</MudPaper>

@code
{
    [Parameter]
    public int RoomId { get; set; }

    private bool _isLoading = false;
    private string _loadingMessage = "";

    private bool _isReceiverJoined = false;
    private ConnectionTypeEnum _connectionType = ConnectionTypeEnum.None;
    private bool _isAllowSend = false;

    private HubConnection _hub = null!;
    private DotNetObjectReference<FileTransferSender> _objRef = null!;

    private string _fileSendName = "";
    private byte[] _fileSendArray;
    private string _fileSendSHA1 = "";
    private int _fileSendSize => _fileSendArray.Length;

    private double _fileSentProgress;

    private static readonly string DefaultDragClass = "relative rounded-lg border-2 border-dashed pa-4 mud-width-full mud-height-full z-10";
    private string _dragClass = DefaultDragClass;

    private readonly List<string> _messages = new List<string>();

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        try
        {
            if (RoomId < 100000 || RoomId > 999999)
            {
                throw new ArgumentException("非法请求");
            }

            Console.WriteLine($"准备初始化房间({RoomId})....");
            _objRef = DotNetObjectReference.Create(this);

            _hub = new HubConnectionBuilder()
                .WithUrl($"{Configuration["WebAPIHost"]}/file-transfer-hub")
                .Build();


            _hub.On("ReceiverJoin", async () =>
            {
                Console.WriteLine("接收方进入");
                _isReceiverJoined = true;
                await InvokeAsync(StateHasChanged);
                await JSRuntime.InvokeVoidAsync("createSenderConnection");
            });

            _hub.On<string>("ReceiveReceiverIceCandidate", async (candidate) =>
            {
                Console.WriteLine("收到接收方候选人信息");
                await InvokeAsync(StateHasChanged);
                await JSRuntime.InvokeVoidAsync("receiveIceCandidate", candidate);
            });

            _hub.On<string>("ReceiveAnswer", async (answer) =>
            {
                Console.WriteLine("收到网络通道响应指令");
                await JSRuntime.InvokeVoidAsync("receiveAnswer", answer);
                await InvokeAsync(StateHasChanged);
            });
            await _hub.StartAsync();

            await JSRuntime.InvokeVoidAsync("initialization", _objRef, Configuration["StunServer"]);

            _messages.Add($"准备创建房间，房间号 {RoomId}....");
            var json = await _hub.InvokeAsync<string>("CreateRoom", RoomId);
            var result = json.ToObject<ApiResult>();
            if (result is not { Code: 0 })
            {
                _messages.Add($"房间创建失败：{result?.Message ?? "连接服务器失败"}");
                return;
            }
            _messages.Add("房间创建成功");
            Console.WriteLine("等待接收方进入....");
            await InvokeAsync(StateHasChanged);

        }
        catch (Exception ex)
        {
            await Dialog.ShowMessageBox("提示", ex.Message, yesText: "确定");
            NavigationManager.NavigateTo($"/file-transfer");
        }
    }

    [JSInvokable]
    public async Task SendIceCandidateToServer(string candidate)
    {
        Console.WriteLine("准备发送候选人信息....");
        await _hub.InvokeAsync<string>("SendSenderIceCandidate", RoomId, candidate);
    }

    [JSInvokable]
    public async Task SendOfferToServer(string offer)
    {
        Console.WriteLine("准备发送网络通道请求指令....");
        await _hub.InvokeAsync<string>("SendOffer", RoomId, offer);
    }

    [JSInvokable]
    public async Task SenderConnected()
    {
        //发送端准备就绪
        _connectionType = ConnectionTypeEnum.WebRTC;
        _messages.Add("点对点连接已建立");
        await InvokeAsync(StateHasChanged);
    }

    public async Task EnableServiceRelay()
    {
        _connectionType = ConnectionTypeEnum.ServiceRelay;
        _messages.Add("启用服务器中转传输");
        await _hub.InvokeAsync<string>("SwitchConnectionType", RoomId);
        await InvokeAsync(StateHasChanged);
    }

    private async void OnInputFileChanged(InputFileChangeEventArgs e)
    {
        ClearDragClass();
        long maxFileSize = 100000000;
        if (e.GetMultipleFiles()[0].Size >= maxFileSize)
        {
            var options = new DialogOptions()
                {
                    NoHeader = true
                };
            var parameters = new DialogParameters();
            parameters.Add("ContentText", "文件大小超过系统限制");
            Dialog.Show<DialogOk>("提示", parameters, options);
            return;
        }
        await LoadingAsync("正在生成文件元数据...");

        _fileSendName = e.GetMultipleFiles()[0].Name;
        var ms = new MemoryStream();
        await e.GetMultipleFiles()[0].OpenReadStream(maxFileSize).CopyToAsync(ms);
        _fileSendArray = ms.ToArray();

        var hashService = HashServiceFactory.Create(HashTypeEnum.SHA1);
        _fileSendSHA1 = await hashService.ComputeHashAsync(_fileSendArray, false);
        _isAllowSend = true;
        await LoadingCompletedAsync();
    }
    private void SetDragClass()
    {
        _dragClass = $"{DefaultDragClass} mud-border-primary";
    }

    private void ClearDragClass()
    {
        _dragClass = DefaultDragClass;
    }

    private async Task SendFileAsync()
    {
        var fileInfo = new FileTransferInfo()
            {
                FileName = _fileSendName,
                SHA1 = _fileSendSHA1,
                FileSize = _fileSendSize
            };

        _messages.Add($"发送文件元数据：");
        _messages.Add($"文件名：{fileInfo.FileName}");
        _messages.Add($"大小：{fileInfo.FileSize}");
        _messages.Add("准备发送文件....");


        if (_connectionType == ConnectionTypeEnum.WebRTC)
        {
            await JSRuntime.InvokeVoidAsync("sendFileInfo", fileInfo.ToJson());
            await JSRuntime.InvokeVoidAsync("sendFile", _fileSendArray);
        }
        else if (_connectionType == ConnectionTypeEnum.ServiceRelay)
        {
            await _hub.InvokeAsync("SendFileInfo", fileInfo.ToJson());
            await SendFileWithSignalRAsync();
        }
    }

    private int _chunkSize = 16384;
    private async Task SendFileWithSignalRAsync()
    {
        int totalBytesSent = 0;

        for (int offset = 0; offset < _fileSendArray.Length; offset += _chunkSize)
        {
            int remainingBytes = _fileSendArray.Length - offset;
            int chunkToSend = Math.Min(_chunkSize, remainingBytes);
            byte[] chunk = new byte[chunkToSend];
            Array.Copy(_fileSendArray, offset, chunk, 0, chunkToSend);

            await _hub.InvokeAsync("SendFile", chunk);

            totalBytesSent += chunkToSend;
            _fileSentProgress = (double)totalBytesSent / _fileSendArray.Length * 100;

            await InvokeAsync(StateHasChanged);
            await Task.Delay(20);
        }
        await _hub.InvokeAsync("SendFileSent");
        _messages.Add("文件发送完成");
    }

    [JSInvokable]
    public async Task FileSending(int length)
    {
        _fileSentProgress = ((double)(_fileSendSize - length) / _fileSendSize) * 100;
        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public async Task FileSent()
    {
        await OnSendCompletedAsync();
    }

    private async Task LoadingAsync(string message)
    {
        _isLoading = true;
        _loadingMessage = message;
        await InvokeAsync(StateHasChanged);
    }
    private async Task LoadingCompletedAsync()
    {
        _isLoading = false;
        _loadingMessage = "";
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnSendCompletedAsync()
    {
        _messages.Add("文件发送完成");
        await InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        _objRef?.Dispose();
    }
}