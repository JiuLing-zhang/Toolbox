@page "/file-transfer/receiver/{RoomId:int}"
@using Microsoft.Extensions.Configuration
@using Microsoft.AspNetCore.SignalR.Client
@using Toolbox.Pages.Enums
@using Toolbox.Pages.HashCheckService
@using Toolbox.Pages.Models
@using Toolbox.Pages.Shared.Dialogs

@inject IJSRuntime JSRuntime
@inject IConfiguration Configuration
@inject NavigationManager NavigationManager
@inject IDialogService Dialog
@inject HashServiceFactory HashServiceFactory;

<PageTitle>码术 - 文件传输</PageTitle>

<DialogLoading IsVisible="@_isLoading" ContentText="@_loadingMessage"></DialogLoading>

<MudPaper Width="100%" Elevation="0">
    <MudContainer MaxWidth="MaxWidth.Small">
        <MudPaper Width="100%"
                  Elevation="0"
                  Height="300px"
                  Square="true"
                  Class="pa-5">

            <MudField Label=""
                      Class="mb-8"
                      Variant="Variant.Text"
                      Adornment="Adornment.End"
                      AdornmentIcon="@Icons.Material.Filled.CheckCircle"
                      AdornmentColor="Color.Success">
                @($"房间号 {RoomId}")
            </MudField>

            @if (_connectionType == ConnectionTypeEnum.None)
            {
                <div class="d-flex align-center">
                    <MudProgressCircular Color="Color.Primary"
                                         Indeterminate="true"
                                         Size="Size.Small" />
                    <MudText Typo="@Typo.caption" Class="ml-2">正在连接....</MudText>
                </div>
            }
            else
            {
                if (_fileMetadata == null)
                {
                    <div class="d-flex align-center">
                        <MudProgressCircular Color="Color.Primary"
                                             Indeterminate="true"
                                             Size="Size.Small" />
                        <MudText Typo="@Typo.caption" Class="ml-2">等待发送文件....</MudText>
                    </div>
                }
                else
                {
                    switch (_connectionType)
                    {
                        case ConnectionTypeEnum.WebRTC:
                            <MudText Typo="@Typo.caption">点对点接收</MudText>
                            break;
                        case ConnectionTypeEnum.ServiceRelay:
                            <MudText Typo="@Typo.caption">服务器中转接收</MudText>
                            break;
                    }

                    <MudText Typo="Typo.overline" Class="mt-1">@_fileMetadata.FileName</MudText>

                    <MudProgressLinear Striped="true"
                                       Color="Color.Info"
                                       Size="Size.Large"
                                       Value="@_progress"
                                       Class="mt-3">
                        <MudText Typo="Typo.subtitle1" Color="Color.Dark">
                            <b>@($"{Convert.ToInt32(_progress)}%")</b>
                        </MudText>
                    </MudProgressLinear>

                    <MudButton Class="mt-5"
                               Disabled="@(!_isFileReceived)"
                               Variant="Variant.Filled"
                               Color="Color.Info"
                               OnClick="@(async () => await DownloadFileAsync())">下载</MudButton>
                }
            }

        </MudPaper>

        <MudPaper Width="100%"
                  Elevation="0"
                  Square="true"
                  Class="pa-5">

            <MudList Clickable="false" Dense="true" DisableGutters="false">
                @foreach (var message in _messages)
                {
                    <MudListItem Text="@(message)" />
                }
            </MudList>

        </MudPaper>
    </MudContainer>
</MudPaper>

@code
{
    [Parameter]
    public int RoomId { get; set; }

    private bool _isLoading = false;
    private string _loadingMessage = "";
    private ConnectionTypeEnum _connectionType = ConnectionTypeEnum.None;

    private HubConnection _hub = null!;
    private DotNetObjectReference<FileTransferReceiver> _objRef = null!;

    private bool _isFileReceived = false;

    private FileTransferInfo? _fileMetadata;
    private readonly List<byte> _fileBuffer = new();
    private double _progress;

    private readonly List<string> _messages = new List<string>();
    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        Console.WriteLine($"准备初始化模块....");
        _objRef = DotNetObjectReference.Create(this);

        _hub = new HubConnectionBuilder()
            .WithUrl($"{Configuration["WebAPIHost"]}/file-transfer-hub")
            .Build();

        _hub.On<string>("ReceiveSenderIceCandidate", async (candidate) =>
        {
            Console.WriteLine("收到发送方候选人信息");
            await InvokeAsync(StateHasChanged);
            await JSRuntime.InvokeVoidAsync("receiveIceCandidate", candidate);
        });

        _hub.On<string>("ReceiveOffer", async (offer) =>
        {
            Console.WriteLine("收到网络通道请求指令");
            await InvokeAsync(StateHasChanged);
            await JSRuntime.InvokeVoidAsync("createReceiverConnection", offer);
        });
        _hub.On("ReceiveSwitchConnectionType", async () =>
        {
            //切换服务器中转模式
            _connectionType = ConnectionTypeEnum.ServiceRelay;
            _messages.Add("启用服务器中转传输");
            await InvokeAsync(StateHasChanged);
        });
        _hub.On<string>("ReceiveFileInfo", async (fileInfo) =>
        {
            await OnReceiveFileInfo(fileInfo);
        });
        _hub.On<byte[]>("ReceiveFile", async (buffer) =>
        {
            await OnFileReceivingAsync(buffer);
        });
        _hub.On("ReceiveFileSent", async () =>
        {
            _messages.Add("文件接收完成");
            await LoadingAsync("正在校验文件");
            var sha1 = await HashServiceFactory.Create(HashTypeEnum.SHA1).ComputeHashAsync(_fileBuffer.ToArray(), false);
            await LoadingCompletedAsync();
            if (_fileMetadata?.SHA1 != sha1)
            {
                _messages.Add("接收失败：文件内容有缺失");
                return;
            }
            _messages.Add("文件校验通过");
            _isFileReceived = true;
            await InvokeAsync(StateHasChanged);
        });

        await _hub.StartAsync();
        await JSRuntime.InvokeVoidAsync("initialization", _objRef, Configuration["StunServer"]);

        _messages.Add($"准备进入房间....");
        var result = await _hub.InvokeAsync<string>("JoinRoom", RoomId);
        if (result != "ok")
        {
            await Dialog.ShowMessageBox("提示", result, yesText: "确定");
            NavigationManager.NavigateTo($"/file-transfer");
            return;
        }
        _messages.Add("进入房间成功");
    }

    [JSInvokable]
    public async Task SendIceCandidateToServer(string candidate)
    {
        Console.WriteLine("准备发送候选人信息....");
        var result = await _hub.InvokeAsync<string>("SendReceiverIceCandidate", candidate);
        Console.WriteLine($"服务器返回:{result}");
    }

    [JSInvokable]
    public async Task SendAnswerToServer(string answer)
    {
        Console.WriteLine("准备发送网络通道响应指令....");
        var result = await _hub.InvokeAsync<string>("SendAnswer", answer);
        Console.WriteLine($"服务器返回:{result}");
        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public async Task ReceiverConnected()
    {
        //接收端准备就绪
        _connectionType = ConnectionTypeEnum.WebRTC;
        _messages.Add("点对点连接已建立");
        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public async Task FileReceivingWithWebRTC(int length)
    {
        if (_fileMetadata != null)
        {
            _progress = ((double)length) / _fileMetadata.FileSize * 100;
        }
        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public async Task FileInfoReceived(string fileInfo)
    {
        await OnReceiveFileInfo(fileInfo);
    }

    private async Task OnReceiveFileInfo(string fileInfo)
    {
        _fileMetadata = fileInfo.ToObject<FileTransferInfo>();
        if (_fileMetadata == null)
        {
            _messages.Add("文件元数据不完整");
            return;
        }

        _messages.Add($"收到文件元数据：");
        _messages.Add($"文件名：{_fileMetadata.FileName}");
        _messages.Add($"大小：{_fileMetadata.FileSize}");
        _messages.Add("准备接收文件....");

        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public async Task FileReceivedWithWebRTC(string sha1)
    {
        _messages.Add("文件接收完成");
        if (_fileMetadata.SHA1 != sha1)
        {
            _messages.Add("接收失败：文件内容有缺失");
            return;
        }
        _messages.Add("文件校验通过");
        _isFileReceived = true;
        await InvokeAsync(StateHasChanged);
    }

    public async Task OnFileReceivingAsync(byte[] buffer)
    {
        _fileBuffer.AddRange(buffer);
        if (_fileMetadata != null)
        {
            _progress = ((double)_fileBuffer.Count) / _fileMetadata.FileSize * 100;
        }
        await InvokeAsync(StateHasChanged);
    }

    private async Task DownloadFileAsync()
    {
        await LoadingAsync("正在下载...");
        if (_connectionType == ConnectionTypeEnum.WebRTC)
        {
            await JSRuntime.InvokeVoidAsync("saveByteArrayToFile", _fileMetadata?.FileName);
        }
        else if (_connectionType == ConnectionTypeEnum.ServiceRelay)
        {
            await JSRuntime.InvokeVoidAsync("saveToFileWithBufferAndName", _fileMetadata?.FileName, _fileBuffer.ToArray());
        }
        await LoadingCompletedAsync();
    }

    private async Task LoadingAsync(string message)
    {
        _isLoading = true;
        _loadingMessage = message;
        await InvokeAsync(StateHasChanged);
    }
    private async Task LoadingCompletedAsync()
    {
        _isLoading = false;
        _loadingMessage = "";
        await InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        _objRef?.Dispose();
    }
}